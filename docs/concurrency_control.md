## 비즈니스 요구사항에 따른 동시성 제어 방안

### 1. 포인트 조회

- 기존
    - 비관적 락 적용
- 개선
    - 낙관적 락 사용
        - 사용이유 - 접근하는 자원에 대한 사용자가 한정적(사용자 본인)이므로 상대적으로 경합이 낮을것으로 예상
        - 사용방법 - Spring jpa의 @Version 을 사용하여 데이터 수정 시 Version 필드를 확인하여 값이 일치하지 않으면 처리하는 방식으로 사용

### 2. 선착순 쿠폰 발급

- 기존
    - 비관적 락 적용
- 개선
    - Redis의 Pub/Sub 분산 락 사용
        - 사용이유 - 많은 사용자들이 같은 자원에 몰리므로 잦은 경합이 발생할 것으로 예상,
        - Redisson 사용이유 - Redis의 setnx, setex 등 의 직접구현이 아닌 의 Lock 인터페이스를 사용하는 방식으로 해결할 수 있음, Lettuce의 스핀락 방식이 아닌 Pub/Sub으로 Redis의 부하가 줄어듬
        - 사용방법 - 락 획득 시 Redis 키를 설정하여 해당 락이 점유상태 일 시 Redis 키의 채널을 구독하여 락 해제 호출을 듣고 락을 점유함

### 3. 상품 재고차감

- 기존
    - 비관적 락 적용
    - 사용이유 - 주문 시 결제, 쿠폰 사용, 포인트 차감 등 여러 단계를 포함하고 있어 다른 트랜잭션에 의한 수정작업으로 데이터 무결성이 깨질 위험을 차단
      결제 로직이 포함되어있어 코드 복잡도를 우려(결제 취소 등)
    - 사용방법 - 상품 조회 시 `select ... for update` 사용, 상품 조회 후 사용자의 주문 수량에 대한 검증을 실시함
    - 고려사항
        - version을 이용한 낙관적 락을 적용할 시
            - 주문 및 결제 로직 전단계에서 상품 차감 후 flush를 하여 version 컬럼의 값이 서로 다를때에 재고차감에 대한 검증을 실시하고 주문을 이어갈 수 있다
        - 공유락 설정 시
            - 주문 및 결제 로직 전단계에서 상품을 공유락으로 설정한뒤 조회하고(공유락은 획득한 자원의 데이터를 다른 트랜잭션에 의해 수정이 불가능하기 때문에) 상품 재고에 대한 검증을 진행, 하지만 먼저 획득한 공유락의 트랜잭션에서 상품에 대한 재고값이 변경되었을 수 있기 때문에 적합하지 않다.